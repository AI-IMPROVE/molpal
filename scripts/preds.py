from argparse import ArgumentParser
import csv
from functools import partial
import gzip
from pathlib import Path
from typing import Dict, List

import numpy as np
from scipy import stats
from tqdm import tqdm

def extract_smis(library, smiles_col=0, title_line=True) -> List:
    if Path(library).suffix == '.gz':
        open_ = partial(gzip.open, mode='rt')
    else:
        open_ = open
    
    with open_(library) as fid:
        reader = csv.reader(fid)
        if title_line:
            next(reader)

        smis = []
        for row in tqdm(reader, desc='Getting smis', leave=False):
            try:
                smis.append(row[smiles_col])
            except ValueError:
                continue

    return smis

def build_true_dict(true_csv, smiles_col: int = 0, score_col: int = 1,
                    title_line: bool = True,
                    maximize: bool = False) -> Dict[str, float]:
    if Path(true_csv).suffix == '.gz':
        open_ = partial(gzip.open, mode='rt')
    else:
        open_ = open
    
    c = 1 if maximize else -1

    with open_(true_csv) as fid:
        reader = csv.reader(fid)
        if title_line:
            next(reader)

        d_smi_score = {}
        for row in tqdm(reader, desc='Building dict', leave=False):
            try:
                d_smi_score[row[smiles_col]] = c * float(row[score_col])
            except ValueError:
                continue

    return d_smi_score

def gather_experiment_predss(experiment) -> List[np.ndarray]:
    chkpts_dir = Path(experiment) / 'chkpts'

    chkpt_iter_dirs = sorted(
        chkpts_dir.iterdir(), key=lambda p: int(p.stem.split('_')[-1])
    )[1:]

    predss = [np.load(chkpt_iter_dir / 'preds.npy')
              for chkpt_iter_dir in chkpt_iter_dirs]

    return predss

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument('-e', '--experiments', '--expts', nargs='+',
                        help='the top-level directory generated by the MolPAL run, I.e., the directory with the "data" and "chkpts" directories.')
    parser.add_argument('-l', '--library',
                        help='the library file used for the corresponding MolPAL run.')
    parser.add_argument('--true-csv',
                        help='a pickle file containing a dictionary of the true scoring data')
    parser.add_argument('--smiles-col', type=int, default=0)
    parser.add_argument('--score-col', type=int, default=1)
    parser.add_argument('--no-title-line', action='store_true', default=False)
    parser.add_argument('--maximize', action='store_true', default=False,
                        help='whether the objective for which you are calculating performance should be maximized.')
    
    args = parser.parse_args()
    args.title_line = not args.no_title_line

    smis = extract_smis(args.library, args.smiles_col, args.title_line)
    d_smi_score = build_true_dict(
        args.true_csv, args.smiles_col, args.score_col,
        args.title_line, args.maximize
    )

    Y_true = np.empty(len(smis))
    mask = np.ones(len(smis), dtype=bool)
    for i, smi in tqdm(enumerate(smis), desc='Building mask', leave=False):
        try:
            Y_true[i] = d_smi_score[smi]
        except KeyError:
            mask[i] = False

    for experiment in args.experiments:
        predss = gather_experiment_predss(experiment)
        for i, preds in enumerate(predss):
            mse = ((Y_true[mask] - preds[mask])**2).mean(axis=0)
            pearson, _ = stats.pearsonr(Y_true[mask], preds[mask])
            spearman, _ = stats.spearmanr(Y_true[mask], preds[mask])
                
            print(
                f'Iteration {i+1}: MSE: {mse:0.3f}, '
                f'pearson: {pearson:0.3f}, spearman: {spearman:0.3f}',
                flush=True
            )

    exit()