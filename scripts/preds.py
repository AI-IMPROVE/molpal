from argparse import ArgumentParser
from collections import Counter, defaultdict
import csv
from functools import partial
import gzip
from pathlib import Path
from typing import Dict, Iterable, List, Sequence, Set, Tuple

from matplotlib import pyplot as plt
from matplotlib import ticker
import numpy as np
from scipy import stats
import seaborn as sns
from tqdm import tqdm

sns.set_theme(style='white', context='paper')

def gather_experiment_predss(experiment) -> List[np.ndarray]:
    preds_dir = Path(experiment) / 'preds'

    preds_paths = sorted(
        preds_dir.iterdir(), key=lambda p: int(p.stem.split('_')[-1])
    )

    predss = [np.load(preds_path) for preds_path in preds_paths]

    return predss

def extract_smis(library, smiles_col=0, title_line=True) -> List:
    if Path(library).suffix == '.gz':
        open_ = partial(gzip.open, mode='rt')
    else:
        open_ = open
    
    with open_(library) as fid:
        reader = csv.reader(fid)
        if title_line:
            next(reader)

        smis = []
        for row in tqdm(reader, desc='Getting smis', leave=False):
            try:
                smis.append(row[smiles_col])
            except ValueError:
                continue

    return smis

def build_true_dict(true_csv, smiles_col: int = 0, score_col: int = 1,
                    title_line: bool = True,
                    maximize: bool = False) -> Dict[str, float]:
    if Path(true_csv).suffix == '.gz':
        open_ = partial(gzip.open, mode='rt')
    else:
        open_ = open
    
    c = 1 if maximize else -1

    with open_(true_csv) as fid:
        reader = csv.reader(fid)
        if title_line:
            next(reader)

        d_smi_score = {}
        for row in tqdm(reader, desc='Building dict', leave=False):
            try:
                d_smi_score[row[smiles_col]] = c * float(row[score_col])
            except ValueError:
                continue

    return d_smi_score

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument('--experiment', '--expt',
                        help='the top-level directory generated by the MolPAL run. I.e., the directory with the "data", "preds", and "states" subdirectories.')
    parser.add_argument('--library',
                        help='the library file used for the corresponding MolPAL run.')
    parser.add_argument('--true-csv',
                        help='a pickle file containing a dictionary of the true scoring data')
    parser.add_argument('--size', type=int,
                        help='the size of the full library which was explored. You only need to specify this if you are using a truncated pickle file. I.e., your pickle file contains only the top 1000 scores because you only intend to calculate results of the top-k, where k <= 1000')
    parser.add_argument('--smiles-col', type=int, default=0)
    parser.add_argument('--score-col', type=int, default=1)
    parser.add_argument('--no-title-line', action='store_true', default=False)
    # parser.add_argument('--mode', required=True,
    #                     choices=('model-metrics', 'split-models', 
    #                              'split-metrics', 'si', 'single-batch', 'convergence', 'csv', 'errors', 
    #                              'diversity', 'intersection'),
    #                     help='what figure to generate. For "x-y" modes, this corresponds to the figure structure, where there will be a separate panel for each "x" and in each panel there will be traces corresponding to each independent "y". E.g., "model-metrics" makes a figure with three sepearate panels, one for each model and inside each panel a trace for each metric. "si" will make the trajectory plots present in the SI.')
    # parser.add_argument('--name', default='.')
    # parser.add_argument('--format', '--fmt', default='png',
    #                     choices=('png', 'pdf'))
    parser.add_argument('--maximize', action='store_true', default=False,
                        help='whether the objective for which you are calculating performance should be maximized.')
    
    args = parser.parse_args()
    args.title_line = not args.no_title_line

    predss = gather_experiment_predss(args.experiment)
    smis = extract_smis(args.library, args.smiles_col, args.title_line)
    d_smi_score = build_true_dict(
        args.true_csv, args.smiles_col, args.score_col,
        args.title_line, args.maximize
    )

    Y_true = np.empty(len(smis))
    mask = np.ones(len(smis), dtype=bool)
    for i, smi in tqdm(enumerate(smis), desc='Building mask', leave=False):
        try:
            Y_true[i] = d_smi_score[smi]
        except KeyError:
            mask[i] = False

    residualss = []
    mses = []
    spearmans = []
    for i, preds in enumerate(predss):
        # print(Y_true, preds)
        mse = ((Y_true[mask] - preds[mask])**2).mean(axis=0)
        pearson, _ = stats.pearsonr(Y_true[mask], preds[mask])
        spearman, _ = stats.spearmanr(Y_true[mask], preds[mask])
            
        print(
            f'Iteration {i+1}: MSE: {mse:0.3f}, '
            f'pearson: {pearson:0.3f}, spearman: {spearman:0.3f}',
            flush=True
        )
